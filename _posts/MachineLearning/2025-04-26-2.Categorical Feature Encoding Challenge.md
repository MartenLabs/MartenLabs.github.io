---
title: 2. Categorical Feature Encoding Challenge
date: 2025-04-26T09:30:00+09:00
categories: [Machine Learning, Part3]
tags:
  [
    Machine Learning,
    이론,
    개념,
    이진분류, 
    로지스틱 회귀
  ]
pin: true
math: true
mermaid: true
share: true 
comments: true
---

# 1. Categorical Feature Encoding Challenge

<br/>

- [범주형 데이터 이진분류 경진대회 링크](https://www.kaggle.com/c/cat-in-the-dat/)  

- [탐색적 데이터 분석 코드 참고 링크](https://www.kaggle.com/kabure/eda-feat-engineering-encode-conquer)

<br/>


| 난이도         | 2                                                                                                                    |      |         |     |
| ----------- | -------------------------------------------------------------------------------------------------------------------- | ---- | ------- | --- |
| 경진대회명       | 범주형 데이터 이진분류 경진대회                                                                                                    |      |         |     |
| 미션          | 다양한 범주형 데이터를 활용해 타겟값 1에 속할 확률 예측                                                                                     |      |         |     |
| 문제유형        | 이진분류                                                                                                                 | 평가지표 | ROC AUC |     |
| 제출시 사용한 모델  | 로지스틱 회귀                                                                                                              |      |         |     |
| 파이썬 버전      | 3.7.10                                                                                                               |      |         |     |
| 사용 라이브러리 버전 | numpy == 1.19.5<br>pandas == 1.3.2<br>seaborn == 0.11.2<br>matplotlib == 3.4.3<br>sklearn == 0.32.2<br>scipy ==1.7.1 |      |         |     |

<br/>

### 학습 목표 
- 범주형 데이터를 활용해 이진분류하는 경진대회에 참가
- 피처 구성을 이해하기 위해 탐색적 데이터 분석을 자세히 학습
- 데이터 특성에 따른 맞춤형 인코딩 방법 학습
- 최종적으로 프라이빗 리더보드에서 2등을 기록하는 모델 제작

<br/>

### 학습 순서 
1. 경진대회 이해 
2. 탐색적 데이터 분석 
3. 베이스라인 모델(로지스틱 회귀)
4. 성능개선 I (피처 엔지니어링 강화)
5. 성능 개선 II (검증 데이터까지 훈련에 이용)

<br/>

### 학습 키워드
- **유형 및 평가 지표** : 이진분류, ROC AUC
- **탐색적 데이터 분석** : 피처 요약표, 타겟값 분포, 이진/명목형/순서형/날짜 피처 분포
- **머신러닝 모델** : 로지스틱 회귀
- **피처 앤지니어링** : 원-핫 인코딩, 피처 맞춤 인코딩, 피처 스케일링
- **하이퍼파라미터 최적화** : 그리드 서치 

<br/>
<br/>
<br/>

---
## 1. 경진대회 이해

- 본 대회의 목표는 범주형 feature 23개를 활용해 해당 데이터가 타겟값 1에 속할 확률을 예측하는 것이다.

<br/>

- 본 경진대회의 특징
	- 본 대회는 인위적으로 만든 데이터를 제공한다. (연습용으로는 인공 데이터가 오히려 좋다.)

	- 각 피처와 타겟값의 의미를 알 수 없다.  자전거 대여 수요 예측은 다르게 날씨가 좋을수록 자전거 대여 수량이 많을것이라 예상할 수 있었지만 이런 경우 활용할 수 있는 배경 지식이 없기 때문에 순전히 데이터만 보고 접근해야 한다.

	- 제공되는 데이터가 모두 범주형이다. 값이 두개로만 구성된 데이터부터 순서형 데이터(ordinal data), 명목형 데이터(nominal data), 날짜 데이터까지 다양하게 제공된다. 
		- bin_로 시작하는 피처는 이진 피처, nom_로 시작하는 피처는 명목형 피처, ord_로 시작하는 피처는 순서형 피처이다.
		- 순서형 피처 중 ord_3, ord_4, ord_5 는 알파벳순으로 고윳값 순서가 매져있다.

	- 타겟값도 범주형 데이터 이다. 0과 1 두개로 구성되어 있다.

<br/>

#### 확률 예측

> 분류 문제에서는 타겟값이 0이냐 1이냐가 아니라 '1일 확률'을 예측한다. 
보통 음성 값일 확률보다는 양성 값일 확률로 예측한다. 일반적으로 0은 음성, 1은 양성을 나타낸다. 스팸 메일을 거르는 문제라면 0은 일반 메일, 1은 스팸 메일을 뜻한다. 암을 진단하는 문제에서도 0은 정상, 1은 암 진단을 의미한다. 이런 문제들에서 우리가 알고싶은건 스팸 메일일 확률이나 암일 확률이기 때문에 양성값인 1일 확률을 예측한다.


<br/>
<br/>
<br/>

## 2. 탐색적 데이터 분석

분석 과정은 아래와 같은 순서로 진행된다.

<p align="center"><img src="https://tera.dscloud.me:8080/Images/MachineLearning기초/Part3/2.Categorical_Feature_Encoding_Challenge/1.jpeg" width="70%" height="70%"></p>

<br/>

### 2.1 탐색적 데이터 분석

> kaggle competitions download -c cat-in-the-dat

<br/>
<br/>

#### 데이터 로드 및 shape 확인 

데이터를 읽어올 때 index_col 파라미터에 데이터가 가지고 있는 id를 전달했다. 열 이름을 전달하면 해당 열을 인덱스로 지정하며 명시하지 않으면 0부터 시작하는 새로운 열을 생성해준다.


``` python
import pandas as pd
import numpy as np

data_path = 'datasets/'

train = pd.read_csv(data_path + 'train.csv', index_col = 'id')
test = pd.read_csv(data_path + 'test.csv', index_col = 'id')
submission = pd.read_csv(data_path + 'sample_submission.csv', index_col = 'id')

print(train.shape, test.shape)

'''
(300000, 24) (200000, 23)
'''
```

<p align="center"><img src="https://tera.dscloud.me:8080/Images/MachineLearning기초/Part3/2.Categorical_Feature_Encoding_Challenge/2.jpeg" width="70%" height="70%"></p>


<br/>
<br/>

train, test, submission의 첫 5행 출력 

``` python
train.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>bin_0</th>
      <th>bin_1</th>
      <th>bin_2</th>
      <th>bin_3</th>
      <th>bin_4</th>
      <th>nom_0</th>
      <th>nom_1</th>
      <th>nom_2</th>
      <th>nom_3</th>
      <th>nom_4</th>
      <th>...</th>
      <th>nom_9</th>
      <th>ord_0</th>
      <th>ord_1</th>
      <th>ord_2</th>
      <th>ord_3</th>
      <th>ord_4</th>
      <th>ord_5</th>
      <th>day</th>
      <th>month</th>
      <th>target</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>T</td>
      <td>Y</td>
      <td>Green</td>
      <td>Triangle</td>
      <td>Snake</td>
      <td>Finland</td>
      <td>Bassoon</td>
      <td>...</td>
      <td>2f4cb3d51</td>
      <td>2</td>
      <td>Grandmaster</td>
      <td>Cold</td>
      <td>h</td>
      <td>D</td>
      <td>kr</td>
      <td>2</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>T</td>
      <td>Y</td>
      <td>Green</td>
      <td>Trapezoid</td>
      <td>Hamster</td>
      <td>Russia</td>
      <td>Piano</td>
      <td>...</td>
      <td>f83c56c21</td>
      <td>1</td>
      <td>Grandmaster</td>
      <td>Hot</td>
      <td>a</td>
      <td>A</td>
      <td>bF</td>
      <td>7</td>
      <td>8</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>F</td>
      <td>Y</td>
      <td>Blue</td>
      <td>Trapezoid</td>
      <td>Lion</td>
      <td>Russia</td>
      <td>Theremin</td>
      <td>...</td>
      <td>ae6800dd0</td>
      <td>1</td>
      <td>Expert</td>
      <td>Lava Hot</td>
      <td>h</td>
      <td>R</td>
      <td>Jc</td>
      <td>7</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>F</td>
      <td>Y</td>
      <td>Red</td>
      <td>Trapezoid</td>
      <td>Snake</td>
      <td>Canada</td>
      <td>Oboe</td>
      <td>...</td>
      <td>8270f0d71</td>
      <td>1</td>
      <td>Grandmaster</td>
      <td>Boiling Hot</td>
      <td>i</td>
      <td>D</td>
      <td>kW</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>F</td>
      <td>N</td>
      <td>Red</td>
      <td>Trapezoid</td>
      <td>Lion</td>
      <td>Canada</td>
      <td>Oboe</td>
      <td>...</td>
      <td>b164b72a7</td>
      <td>1</td>
      <td>Grandmaster</td>
      <td>Freezing</td>
      <td>a</td>
      <td>R</td>
      <td>qP</td>
      <td>7</td>
      <td>8</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 24 columns</p>
</div>

<br/>
<br/>

train.head()로 출력하면 중간에 피처가 생략된 상태로 출력돼 보기 불편하다. 이때 T 메서드를 호출하면 한눈에 보기 편하게 행과 열의 위치가 바뀐다.

``` python
train.head().T
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>id</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bin_0</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>bin_1</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>bin_2</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>bin_3</th>
      <td>T</td>
      <td>T</td>
      <td>F</td>
      <td>F</td>
      <td>F</td>
    </tr>
    <tr>
      <th>bin_4</th>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
      <td>N</td>
    </tr>
    <tr>
      <th>nom_0</th>
      <td>Green</td>
      <td>Green</td>
      <td>Blue</td>
      <td>Red</td>
      <td>Red</td>
    </tr>
    <tr>
      <th>nom_1</th>
      <td>Triangle</td>
      <td>Trapezoid</td>
      <td>Trapezoid</td>
      <td>Trapezoid</td>
      <td>Trapezoid</td>
    </tr>
    <tr>
      <th>nom_2</th>
      <td>Snake</td>
      <td>Hamster</td>
      <td>Lion</td>
      <td>Snake</td>
      <td>Lion</td>
    </tr>
    <tr>
      <th>nom_3</th>
      <td>Finland</td>
      <td>Russia</td>
      <td>Russia</td>
      <td>Canada</td>
      <td>Canada</td>
    </tr>
    <tr>
      <th>nom_4</th>
      <td>Bassoon</td>
      <td>Piano</td>
      <td>Theremin</td>
      <td>Oboe</td>
      <td>Oboe</td>
    </tr>
    <tr>
      <th>nom_5</th>
      <td>50f116bcf</td>
      <td>b3b4d25d0</td>
      <td>3263bdce5</td>
      <td>f12246592</td>
      <td>5b0f5acd5</td>
    </tr>
    <tr>
      <th>nom_6</th>
      <td>3ac1b8814</td>
      <td>fbcb50fc1</td>
      <td>0922e3cb8</td>
      <td>50d7ad46a</td>
      <td>1fe17a1fd</td>
    </tr>
    <tr>
      <th>nom_7</th>
      <td>68f6ad3e9</td>
      <td>3b6dd5612</td>
      <td>a6a36f527</td>
      <td>ec69236eb</td>
      <td>04ddac2be</td>
    </tr>
    <tr>
      <th>nom_8</th>
      <td>c389000ab</td>
      <td>4cd920251</td>
      <td>de9c9f684</td>
      <td>4ade6ab69</td>
      <td>cb43ab175</td>
    </tr>
    <tr>
      <th>nom_9</th>
      <td>2f4cb3d51</td>
      <td>f83c56c21</td>
      <td>ae6800dd0</td>
      <td>8270f0d71</td>
      <td>b164b72a7</td>
    </tr>
    <tr>
      <th>ord_0</th>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>ord_1</th>
      <td>Grandmaster</td>
      <td>Grandmaster</td>
      <td>Expert</td>
      <td>Grandmaster</td>
      <td>Grandmaster</td>
    </tr>
    <tr>
      <th>ord_2</th>
      <td>Cold</td>
      <td>Hot</td>
      <td>Lava Hot</td>
      <td>Boiling Hot</td>
      <td>Freezing</td>
    </tr>
    <tr>
      <th>ord_3</th>
      <td>h</td>
      <td>a</td>
      <td>h</td>
      <td>i</td>
      <td>a</td>
    </tr>
    <tr>
      <th>ord_4</th>
      <td>D</td>
      <td>A</td>
      <td>R</td>
      <td>D</td>
      <td>R</td>
    </tr>
    <tr>
      <th>ord_5</th>
      <td>kr</td>
      <td>bF</td>
      <td>Jc</td>
      <td>kW</td>
      <td>qP</td>
    </tr>
    <tr>
      <th>day</th>
      <td>2</td>
      <td>7</td>
      <td>7</td>
      <td>2</td>
      <td>7</td>
    </tr>
    <tr>
      <th>month</th>
      <td>2</td>
      <td>8</td>
      <td>2</td>
      <td>1</td>
      <td>8</td>
    </tr>
    <tr>
      <th>target</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>

<br/>
<br/>

테스트 데이터 인덱스가 300,000 부터 시작하기 때문에 submission id는 300,000 부터 시작한다.

``` python
submission.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>target</th>
    </tr>
    <tr>
      <th>id</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>300000</th>
      <td>0.5</td>
    </tr>
    <tr>
      <th>300001</th>
      <td>0.5</td>
    </tr>
    <tr>
      <th>300002</th>
      <td>0.5</td>
    </tr>
    <tr>
      <th>300003</th>
      <td>0.5</td>
    </tr>
    <tr>
      <th>300004</th>
      <td>0.5</td>
    </tr>
  </tbody>
</table>
</div>

<br/>
<br/>

``` python
test.head().T
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>id</th>
      <th>300000</th>
      <th>300001</th>
      <th>300002</th>
      <th>300003</th>
      <th>300004</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bin_0</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>bin_1</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>bin_2</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>bin_3</th>
      <td>T</td>
      <td>T</td>
      <td>F</td>
      <td>T</td>
      <td>F</td>
    </tr>
    <tr>
      <th>bin_4</th>
      <td>Y</td>
      <td>N</td>
      <td>Y</td>
      <td>Y</td>
      <td>N</td>
    </tr>
    <tr>
      <th>nom_0</th>
      <td>Blue</td>
      <td>Red</td>
      <td>Blue</td>
      <td>Red</td>
      <td>Red</td>
    </tr>
    <tr>
      <th>nom_1</th>
      <td>Triangle</td>
      <td>Square</td>
      <td>Square</td>
      <td>Star</td>
      <td>Trapezoid</td>
    </tr>
    <tr>
      <th>nom_2</th>
      <td>Axolotl</td>
      <td>Lion</td>
      <td>Dog</td>
      <td>Cat</td>
      <td>Dog</td>
    </tr>
    <tr>
      <th>nom_3</th>
      <td>Finland</td>
      <td>Canada</td>
      <td>China</td>
      <td>China</td>
      <td>China</td>
    </tr>
    <tr>
      <th>nom_4</th>
      <td>Piano</td>
      <td>Piano</td>
      <td>Piano</td>
      <td>Piano</td>
      <td>Piano</td>
    </tr>
    <tr>
      <th>nom_5</th>
      <td>0870b0a5d</td>
      <td>a5c276589</td>
      <td>568550f04</td>
      <td>c5725677e</td>
      <td>e70a6270d</td>
    </tr>
    <tr>
      <th>nom_6</th>
      <td>9ceb19dd6</td>
      <td>1ad744242</td>
      <td>1fe17a1fd</td>
      <td>a6542cec0</td>
      <td>97b6a3518</td>
    </tr>
    <tr>
      <th>nom_7</th>
      <td>530f8ecc3</td>
      <td>12e6161c9</td>
      <td>27d6df03f</td>
      <td>30c63bd0c</td>
      <td>a42386065</td>
    </tr>
    <tr>
      <th>nom_8</th>
      <td>9d117320c</td>
      <td>46ae3059c</td>
      <td>b759e21f0</td>
      <td>0b6ec68ff</td>
      <td>f91f3b1ee</td>
    </tr>
    <tr>
      <th>nom_9</th>
      <td>3c49b42b8</td>
      <td>285771075</td>
      <td>6f323c53f</td>
      <td>b5de3dcc4</td>
      <td>967cfa9c9</td>
    </tr>
    <tr>
      <th>ord_0</th>
      <td>2</td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>3</td>
    </tr>
    <tr>
      <th>ord_1</th>
      <td>Novice</td>
      <td>Master</td>
      <td>Expert</td>
      <td>Contributor</td>
      <td>Grandmaster</td>
    </tr>
    <tr>
      <th>ord_2</th>
      <td>Warm</td>
      <td>Lava Hot</td>
      <td>Freezing</td>
      <td>Lava Hot</td>
      <td>Lava Hot</td>
    </tr>
    <tr>
      <th>ord_3</th>
      <td>j</td>
      <td>l</td>
      <td>a</td>
      <td>b</td>
      <td>l</td>
    </tr>
    <tr>
      <th>ord_4</th>
      <td>P</td>
      <td>A</td>
      <td>G</td>
      <td>Q</td>
      <td>W</td>
    </tr>
    <tr>
      <th>ord_5</th>
      <td>be</td>
      <td>RP</td>
      <td>tP</td>
      <td>ke</td>
      <td>qK</td>
    </tr>
    <tr>
      <th>day</th>
      <td>5</td>
      <td>7</td>
      <td>1</td>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <th>month</th>
      <td>11</td>
      <td>5</td>
      <td>12</td>
      <td>3</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>

<br/>
<br/>
<br/>

### 2.2 피처 요약표 생성

피처 요약표는 피처별 데이터 타입, 결측값 개수, 고윳값 개수, 실제 입력값 등을 정리한 표이다.

<br/>

> 피처 요약표를 만드는 3단계

**1. 피처별 데이터 타입 DataFrame 생성***
   
**2. 인덱스 재설정 후 열 이름 변경**

**3. 결측값 개수, 고윳값 개수, 1~3행 입력값 추가**

<br/>

#### 1. 피처별 데이터 타입 DataFrame 생성 

DataFrame 객체에서 dtypes를 호출하면 피처별 데이터 타입을 반환해준다.

``` python
train.dtypes

'''
bin_0      int64
bin_1      int64
bin_2      int64
bin_3     object
bin_4     object
nom_0     object
nom_1     object
nom_2     object
nom_3     object
nom_4     object
nom_5     object
nom_6     object
nom_7     object
nom_8     object
nom_9     object
ord_0      int64
ord_1     object
ord_2     object
ord_3     object
ord_4     object
ord_5     object
day        int64
month      int64
target     int64
dtype: object
'''
```

<br/>
<br/>

이 값을 입력으로 DataFrame을 새로 생성하면 피처별 데이터 타입이 입력된 DataFrame이 만들어진다. 이 때 다음과 같이 columns 파라미터로 원하는 열 이름을 설정할 수 있다.

``` python
summary = pd.DataFrame(train.dtypes, columns = ['데이터 타입'])
summary.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>데이터 타입</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bin_0</th>
      <td>int64</td>
    </tr>
    <tr>
      <th>bin_1</th>
      <td>int64</td>
    </tr>
    <tr>
      <th>bin_2</th>
      <td>int64</td>
    </tr>
    <tr>
      <th>bin_3</th>
      <td>object</td>
    </tr>
    <tr>
      <th>bin_4</th>
      <td>object</td>
    </tr>
  </tbody>
</table>
</div>

<br/>
<br/>

#### 2. 인덱스 재설정 후 열 이름 변경

현재 피처 이름들이 인덱스로 사용중이기 떄문에 현재 인덱스를 열로 옮기고 새로운 인덱스를 만든다.

reset_index()를 호출하면 현재 인덱스를 열로 옮기고 새로운 인덱스를 만든다. 새로운 인덱스는 0부터 시작해 1씩 증가하는 정수이며, 옮겨진 열의 이름은 'index'가 된다.

``` python
summary = summary.reset_index()

summary.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>데이터 타입</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bin_0</td>
      <td>int64</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bin_1</td>
      <td>int64</td>
    </tr>
    <tr>
      <th>2</th>
      <td>bin_2</td>
      <td>int64</td>
    </tr>
    <tr>
      <th>3</th>
      <td>bin_3</td>
      <td>object</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bin_4</td>
      <td>object</td>
    </tr>
  </tbody>
</table>
</div>


<br/>
<br/>

현재 피처 이름이 포함된 열 이름이 index 이기 때문에 rename()함수를 사용해 열 이름을 '피처'로 바꾼다.

``` python
summary = summary.rename(columns={'index':'피처'})

summary.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>피처</th>
      <th>데이터 타입</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bin_0</td>
      <td>int64</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bin_1</td>
      <td>int64</td>
    </tr>
    <tr>
      <th>2</th>
      <td>bin_2</td>
      <td>int64</td>
    </tr>
    <tr>
      <th>3</th>
      <td>bin_3</td>
      <td>object</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bin_4</td>
      <td>object</td>
    </tr>
  </tbody>
</table>
</div>

<br/>
<br/>

#### 3. 결측값 개수, 고유값 개수, 1~3행 입력값 추가

DataFrame에 결측값 개수, 고윳값 개수, 첫 세 개 행에 입력된 값을 추가해 보자.

1. 피처별 결측값 개수를 DataFrame에 추가한다. isnull()은 결측값 포함 여부를 True, False로 반환하는 함수이다. True는 1, False는 0으로 간주되어 isnull()을 적용한 DataFrame에 sum() 함수를 호출하면 True의 개수, 즉 피처별 결측값 개수를 구해준다.

2. 피처별 고유값 개수를 추가한다. nunique()는 피처별 고윳값 개수를 구하는 함수이다.  

3. 훈련 데이터 1~3행에 입력된 값을 요약표 DataFrame에 추가한다. 각 피처에 실제 어떤 값들이 들어있는지 확인하기 위함이다. loc[0]은 첫 번째 행, loc[1]은 두번째 행, loc[2]는 세번째 행의 값을 의미한다.

<p align="center"><img src="https://tera.dscloud.me:8080/Images/MachineLearning기초/Part3/2.Categorical_Feature_Encoding_Challenge/3.jpeg" width="70%" height="70%"></p>

values 를 적용하지 않으면 반환 타입인 Series는 인덱스(bin_0, bin_1 등)과 값(0 등)의 쌍으로 이루어져 있다. 따라서 values를 호출해 값만 추출하여 summary에 추가한다.

<br/>

| `axis` 값 | 기준 방향            | 작동 방향   | 의미                  |
| -------- | ---------------- | ------- | ------------------- |
| `axis=0` | **행(row)** 기준    | 위→아래 방향 | **열(column) 단위 계산** |
| `axis=1` | **열(column)** 기준 | 왼→오 방향  | **행(row) 단위 계산**    |


``` python
# 1. 피처별 결측값 개수
summary['결측값 개수'] = train.isnull().sum().values
'''
- isnull() ➝ 원소 단위로 작동해서 True / False 값을 가진 동일 크기의 DataFrame을 반환
- sum() ➝ 기본적으로 열 단위(axis=0)로 작동해서 각 열의 결측값 개수를 반환
'''

# 2. 피처별 고윳값 개수
summary['고윳값 개수'] = train.nunique().values
'''
nunique()는 기본적으로 열(axis=0) 단위로 작동
'''
# 3. 1~3행에 입력되어 있는 값
summary['첫 번째 값'] = train.loc[0].values
summary['두 번째 값'] = train.loc[1].values
summary['세 번째 값'] = train.loc[1].values

summary.head()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>피처</th>
      <th>데이터 타입</th>
      <th>결측값 개수</th>
      <th>고윳값 개수</th>
      <th>첫 번째 값</th>
      <th>두 번째 값</th>
      <th>세 번째 값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bin_0</td>
      <td>int64</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bin_1</td>
      <td>int64</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>bin_2</td>
      <td>int64</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>bin_3</td>
      <td>object</td>
      <td>0</td>
      <td>2</td>
      <td>T</td>
      <td>T</td>
      <td>T</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bin_4</td>
      <td>object</td>
      <td>0</td>
      <td>2</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>

<br/>
<br/>

#### 4. 피처 요약표 생성함수 

``` python
def resumetable(df):
    print(f'데이터셋 형상: {df.shape}')

    # 스텝 1: 피처별 데이터 타입 DataFrame 생성
    summary = pd.DataFrame(df.dtypes, columns=['데이터 타입'])
    
    # 스텝 2: 인덱스 재설정 후 열 이름 변경
    # 2-1: 인덱스 재설정
    summary = summary.reset_index()
    # 2-2: 열 이름 변경
    summary = summary.rename(columns={'index': '피처'})
    
    # 스텝 3: 결측값 개수, 고윳값 개수, 1~3행 입력값 추가
    # 피처별 결측값 개수
    summary['결측값 개수'] = df.isnull().sum().values    
    # 피처별 고윳값 개수
    summary['고윳값 개수'] = df.nunique().values
    # 1~3행에 입력되어 있는 값
    summary['첫 번째 값'] = df.loc[0].values
    summary['두 번째 값'] = df.loc[1].values
    summary['세 번째 값'] = df.loc[2].values

    return summary

resumetable(train)
```

데이터셋 형상: (300000, 24)

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>피처</th>
      <th>데이터 타입</th>
      <th>결측값 개수</th>
      <th>고윳값 개수</th>
      <th>첫 번째 값</th>
      <th>두 번째 값</th>
      <th>세 번째 값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>bin_0</td>
      <td>int64</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bin_1</td>
      <td>int64</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>bin_2</td>
      <td>int64</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>bin_3</td>
      <td>object</td>
      <td>0</td>
      <td>2</td>
      <td>T</td>
      <td>T</td>
      <td>F</td>
    </tr>
    <tr>
      <th>4</th>
      <td>bin_4</td>
      <td>object</td>
      <td>0</td>
      <td>2</td>
      <td>Y</td>
      <td>Y</td>
      <td>Y</td>
    </tr>
    <tr>
      <th>5</th>
      <td>nom_0</td>
      <td>object</td>
      <td>0</td>
      <td>3</td>
      <td>Green</td>
      <td>Green</td>
      <td>Blue</td>
    </tr>
    <tr>
      <th>6</th>
      <td>nom_1</td>
      <td>object</td>
      <td>0</td>
      <td>6</td>
      <td>Triangle</td>
      <td>Trapezoid</td>
      <td>Trapezoid</td>
    </tr>
    <tr>
      <th>7</th>
      <td>nom_2</td>
      <td>object</td>
      <td>0</td>
      <td>6</td>
      <td>Snake</td>
      <td>Hamster</td>
      <td>Lion</td>
    </tr>
    <tr>
      <th>8</th>
      <td>nom_3</td>
      <td>object</td>
      <td>0</td>
      <td>6</td>
      <td>Finland</td>
      <td>Russia</td>
      <td>Russia</td>
    </tr>
    <tr>
      <th>9</th>
      <td>nom_4</td>
      <td>object</td>
      <td>0</td>
      <td>4</td>
      <td>Bassoon</td>
      <td>Piano</td>
      <td>Theremin</td>
    </tr>
    <tr>
      <th>10</th>
      <td>nom_5</td>
      <td>object</td>
      <td>0</td>
      <td>222</td>
      <td>50f116bcf</td>
      <td>b3b4d25d0</td>
      <td>3263bdce5</td>
    </tr>
    <tr>
      <th>11</th>
      <td>nom_6</td>
      <td>object</td>
      <td>0</td>
      <td>522</td>
      <td>3ac1b8814</td>
      <td>fbcb50fc1</td>
      <td>0922e3cb8</td>
    </tr>
    <tr>
      <th>12</th>
      <td>nom_7</td>
      <td>object</td>
      <td>0</td>
      <td>1220</td>
      <td>68f6ad3e9</td>
      <td>3b6dd5612</td>
      <td>a6a36f527</td>
    </tr>
    <tr>
      <th>13</th>
      <td>nom_8</td>
      <td>object</td>
      <td>0</td>
      <td>2215</td>
      <td>c389000ab</td>
      <td>4cd920251</td>
      <td>de9c9f684</td>
    </tr>
    <tr>
      <th>14</th>
      <td>nom_9</td>
      <td>object</td>
      <td>0</td>
      <td>11981</td>
      <td>2f4cb3d51</td>
      <td>f83c56c21</td>
      <td>ae6800dd0</td>
    </tr>
    <tr>
      <th>15</th>
      <td>ord_0</td>
      <td>int64</td>
      <td>0</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>16</th>
      <td>ord_1</td>
      <td>object</td>
      <td>0</td>
      <td>5</td>
      <td>Grandmaster</td>
      <td>Grandmaster</td>
      <td>Expert</td>
    </tr>
    <tr>
      <th>17</th>
      <td>ord_2</td>
      <td>object</td>
      <td>0</td>
      <td>6</td>
      <td>Cold</td>
      <td>Hot</td>
      <td>Lava Hot</td>
    </tr>
    <tr>
      <th>18</th>
      <td>ord_3</td>
      <td>object</td>
      <td>0</td>
      <td>15</td>
      <td>h</td>
      <td>a</td>
      <td>h</td>
    </tr>
    <tr>
      <th>19</th>
      <td>ord_4</td>
      <td>object</td>
      <td>0</td>
      <td>26</td>
      <td>D</td>
      <td>A</td>
      <td>R</td>
    </tr>
    <tr>
      <th>20</th>
      <td>ord_5</td>
      <td>object</td>
      <td>0</td>
      <td>192</td>
      <td>kr</td>
      <td>bF</td>
      <td>Jc</td>
    </tr>
    <tr>
      <th>21</th>
      <td>day</td>
      <td>int64</td>
      <td>0</td>
      <td>7</td>
      <td>2</td>
      <td>7</td>
      <td>7</td>
    </tr>
    <tr>
      <th>22</th>
      <td>month</td>
      <td>int64</td>
      <td>0</td>
      <td>12</td>
      <td>2</td>
      <td>8</td>
      <td>2</td>
    </tr>
    <tr>
      <th>23</th>
      <td>target</td>
      <td>int64</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>

<br/>
<br/>
<br/>

### 2.3 피처 요약표 해석

1. **이진(binary) 피처: bin_0 ~ bin_4**

2. **명목형(nominal) 피처: nom_0 ~ nom_9**

3. **순서형(ordinal) 피처: ord_0 ~ ord_5**

4. **그 외 피처: day, month, target**

<br/>

#### 1. 이진(binary) 피처: bin_0 ~ bin_4

<p align="center"><img src="https://tera.dscloud.me:8080/Images/MachineLearning기초/Part3/2.Categorical_Feature_Encoding_Challenge/4.jpeg" width="70%" height="70%"></p>

- 이진 피처들은 고윳값이 모두 2개이다. 이중 bin_0, bin_1, bin_2 는 데이터 타입이 int64고, 실젯값이 0 또는 1로 구성돼 있다.
  
- bin_3, bin_4는 object 타입이고, 실젯값은 T 또는 F(bin_3 피처), Y 또는 N(bin_4 피처) 이다.
  
- 따라서 T와 Y는 1로, F와 N은 0으로 인코딩 한다.

<br/>

#### 2. 명목형(nominal) 피처: nom_0 ~ nom_9

<p align="center"><img src="https://tera.dscloud.me:8080/Images/MachineLearning기초/Part3/2.Categorical_Feature_Encoding_Challenge/5.jpeg" width="70%" height="70%"></p>

- 명목형 피처는 모두 object 타입이고 결측값은 없다. nom_0 부터 nom_4는 고윳값이 6개 이하인데, nom_5 부터 nom_9는 고윳값이 많으며 의미를 알 수 없는 값을 확인할 수 있다.

<br/>

#### 3. 순서형(ordinal) 피처: ord_0 ~ ord_5

<p align="center"><img src="https://tera.dscloud.me:8080/Images/MachineLearning기초/Part3/2.Categorical_Feature_Encoding_Challenge/6.jpeg" width="70%" height="70%"></p>

- ord_0 피처만 int64 타입이고 나머지는 object 타입니다. 명목형 데이터와 다르게 순서형 데이터는 순서가 매우 중요하다.

- 순서에 따라 타겟값에 미치는 영향이 다르기 때문에 순서에 유의하여 인코딩 해야한다.


<br/>
<br/>

#### ord_0, ord_1, ord_2 feature 고윳값 확인

unique()함수를 통해 고윳값을 구할 수 있다.

``` python
for i in range(3):
	feature = 'ord_' + str(i)
	print(f'{feature} 고윳값: {train[feature].unique()}')

''' 
ord_0 고윳값: [2 1 3]
ord_1 고윳값: ['Grandmaster' 'Expert' 'Novice' 'Contributor' 'Master']
ord_2 고윳값: ['Cold' 'Hot' 'Lava Hot' 'Boiling Hot' 'Freezing' 'Warm']
'''
```

- unique() 함수는 고윳값이 등장한 순으로 출력한다. ord_0 피처의 고윳값은 숫자 크기에 순서를 맞추면 되고 ord_1 피처의 고윳값은 등급에 따라 Novice, Contributor, Expert, Master, Grandmaster 순으로 맞춘다.

- ord_2 피처는 춥고 더움 정도를 나타내므로 Freezing, Cold, Warm, Hot, Boiling Hot, Lava Hot 순으로 맞춘다.

> 미리 정리해놔야 인코딩할 때 순서에 맞게 매핑하기 편하다.

<br/>
<br/>


#### 고윳값 개수가 많은 ord_3, ord_4, ord_5 feature 고윳값 확인

``` python
for i in range(3, 6):
	feature = 'ord_' + str(i)
	print(f'{feature} 고윳값 : {train[feature].unique()}', end='\n\n')

'''
ord_3 고윳값 : ['h' 'a' 'i' 'j' 'g' 'e' 'd' 'b' 'k' 'f' 'l' 'n' 'o' 'c' 'm']

ord_4 고윳값 : ['D' 'A' 'R' 'E' 'P' 'K' 'V' 'Q' 'Z' 'L' 'F' 'T' 'U' 'S' 'Y' 'B' 'H' 'J'
 'N' 'G' 'W' 'I' 'O' 'C' 'X' 'M']

ord_5 고윳값 : ['kr' 'bF' 'Jc' 'kW' 'qP' 'PZ' 'wy' 'Ed' 'qo' 'CZ' 'qX' 'su' 'dP' 'aP'
 'MV' 'oC' 'RL' 'fh' 'gJ' 'Hj' 'TR' 'CL' 'Sc' 'eQ' 'kC' 'qK' 'dh' 'gM'
 'Jf' 'fO' 'Eg' 'KZ' 'Vx' 'Fo' 'sV' 'eb' 'YC' 'RG' 'Ye' 'qA' 'lL' 'Qh'
 'Bd' 'be' 'hT' 'lF' 'nX' 'kK' 'av' 'uS' 'Jt' 'PA' 'Er' 'Qb' 'od' 'ut'
 'Dx' 'Xi' 'on' 'Dc' 'sD' 'rZ' 'Uu' 'sn' 'yc' 'Gb' 'Kq' 'dQ' 'hp' 'kL'
 'je' 'CU' 'Fd' 'PQ' 'Bn' 'ex' 'hh' 'ac' 'rp' 'dE' 'oG' 'oK' 'cp' 'mm'
 'vK' 'ek' 'dO' 'XI' 'CM' 'Vf' 'aO' 'qv' 'jp' 'Zq' 'Qo' 'DN' 'TZ' 'ke'
 'cG' 'tP' 'ud' 'tv' 'aM' 'xy' 'lx' 'To' 'uy' 'ZS' 'vy' 'ZR' 'AP' 'GJ'
 'Wv' 'ri' 'qw' 'Xh' 'FI' 'nh' 'KR' 'dB' 'BE' 'Bb' 'mc' 'MC' 'tM' 'NV'
 'ih' 'IK' 'Ob' 'RP' 'dN' 'us' 'dZ' 'yN' 'Nf' 'QM' 'jV' 'sY' 'wu' 'SB'
 'UO' 'Mx' 'JX' 'Ry' 'Uk' 'uJ' 'LE' 'ps' 'kE' 'MO' 'kw' 'yY' 'zU' 'bJ'
 'Kf' 'ck' 'mb' 'Os' 'Ps' 'Ml' 'Ai' 'Wc' 'GD' 'll' 'aF' 'iT' 'cA' 'WE'
 'Gx' 'Nk' 'OR' 'Rm' 'BA' 'eG' 'cW' 'jS' 'DH' 'hL' 'Mf' 'Yb' 'Aj' 'oH'
 'Zc' 'qJ' 'eg' 'xP' 'vq' 'Id' 'pa' 'ux' 'kU' 'Cl']
'''
```

> ord_3, ord_4, ord_5 피처는 알파벳순으로 정렬되어 있다. 이 피처들은 알파벳순으로 인코딩 한다.

<br/>
<br/>

#### 그 외 features: day, month, target

``` python
print('day 고윳값: ', train['day'].unique())
print('month 고윳값: ', train['month'].unique())
print('target 고윳값: ', train['target'].unique())

'''
day 고윳값:  [2 7 5 4 3 1 6]
month 고윳값:  [ 2  8  1  4 10  3  7  9 12 11  5  6]
target 고윳값:  [0 1]
'''
```

- day 피처의 고윳값이 7개 이다. 요일을 나타낸다고 짐작할 수 있다.

- month 피처의 고윳값은 1부터 12이다. 월을 나타낸다.

- 타겟값은 0 또는 1로 구성돼 있다.





